use serde::{Deserialize, Serialize};

use crate::benchmark::BenchmarkResults;
use crate::merge::MergeSpec;
use crate::research::TechniqueCard;

/// Unique identifier for a variant.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct VariantId(pub String);

impl VariantId {
    pub fn new(id: impl Into<String>) -> Self {
        Self(id.into())
    }
}

impl std::fmt::Display for VariantId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// How a variant was created — either from a research technique or by merging.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VariantOrigin {
    /// Created from a single research technique.
    Research { technique: TechniqueCard },
    /// Created by merging two existing variants.
    Merge { spec: MergeSpec },
}

/// Status of variant generation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum VariantStatus {
    /// Waiting to be generated.
    Pending,
    /// Currently being generated by Claude.
    Generating,
    /// Successfully generated.
    Ready,
    /// Generation failed.
    Failed(String),
}

/// A project variant — a modified copy of the user's project implementing
/// a specific research technique (or a merge of techniques).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Variant {
    /// Unique identifier.
    pub id: VariantId,

    /// Git branch name (e.g., "uniq/variant-1-temporal-fusion-transformer").
    pub branch_name: String,

    /// Display name for the TUI.
    pub display_name: String,

    /// How this variant was created.
    pub origin: VariantOrigin,

    /// Current status.
    pub status: VariantStatus,

    /// Files that were modified or created.
    pub modified_files: Vec<String>,

    /// New dependencies added.
    pub new_dependencies: Vec<String>,

    /// Benchmark results, once available.
    pub benchmark_results: Option<BenchmarkResults>,
}

impl Variant {
    /// Create a new variant from a research technique.
    pub fn from_technique(index: usize, technique: TechniqueCard) -> Self {
        let slug = slugify(&technique.name);
        let branch_name = format!("uniq/variant-{}-{}", index, slug);
        let display_name = format!("V{}: {}", index, technique.name);

        Self {
            id: VariantId::new(format!("variant-{}", index)),
            branch_name,
            display_name,
            origin: VariantOrigin::Research { technique },
            status: VariantStatus::Pending,
            modified_files: Vec::new(),
            new_dependencies: Vec::new(),
            benchmark_results: None,
        }
    }

    /// Create a new variant from merging two existing variants.
    pub fn from_merge(index: usize, spec: MergeSpec, name: String) -> Self {
        let slug = slugify(&name);
        let branch_name = format!("uniq/merge-{}-{}", index, slug);
        let display_name = format!("M{}: {}", index, name);

        Self {
            id: VariantId::new(format!("merge-{}", index)),
            branch_name,
            display_name,
            origin: VariantOrigin::Merge { spec },
            status: VariantStatus::Pending,
            modified_files: Vec::new(),
            new_dependencies: Vec::new(),
            benchmark_results: None,
        }
    }

    /// Whether this variant is a merge of other variants.
    pub fn is_merge(&self) -> bool {
        matches!(self.origin, VariantOrigin::Merge { .. })
    }
}

/// Convert a technique name to a URL/branch-safe slug.
fn slugify(name: &str) -> String {
    name.to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { '-' })
        .collect::<String>()
        .split('-')
        .filter(|s| !s.is_empty())
        .collect::<Vec<_>>()
        .join("-")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_slugify() {
        assert_eq!(
            slugify("Temporal Fusion Transformer"),
            "temporal-fusion-transformer"
        );
        assert_eq!(slugify("BiLSTM + Attention"), "bilstm-attention");
        assert_eq!(slugify("GNN-based  Forecasting"), "gnn-based-forecasting");
    }
}
